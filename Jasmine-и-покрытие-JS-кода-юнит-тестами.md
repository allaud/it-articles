# Intro

Документ рассказывает, каким образом писать юнит-тесты, каким образом это делать с использованием Jasmine, как стоит делать и как поступать не следует.

## Примеры

Примеры тестов (далее - спеков) находятся в проекте [nano.nano_api](https://github.com/KosyanMedia/nano.nano_api) по адресу /spec/javascripts и доступны в браузере по адресу /specs

## Как должны выглядеть тесты.

Юнит-тест должен представлять из себя несколько примеров, демонстрирующих, каким образом программа преобразует вход в выход посредством отдельных частей своего функционала (блоков или юнитов). Юнит-тест придумывается самим разработчиком и должен:

* Быть максимально атомарным
* Сравнивать результат вычислений (действий) тестируемого блока с неким результатом, полученным **другим** способом
* Иметь описание согласно проверямому действию
* Служить примером использования отдельных функциональных блоков
* Учитывать крайние случаи (значения вроде undefined, отсутствие данных, etc.)

Юнит-тест **не** должен:

* Содержать какую-либо логику (if,for,while)
* Сравнивать результат работы блока с результатом работы другого блока
* Сравнивать результат работы блока с результатом работы некоторого алгоритма (описанного в тесте)
* Проверять то, что не должно проверяться или должно проверять другими (например, правильно ли работает обфускатор ассетов)
* Тестировать слишком много - помним про максимальную атомарность. (тест "It loads history records, unserializes them and fullfill search block whith them" - повод задуматься и разбить его на много мелких)

Пример неправильного теста:
>        it('capitalizes',function(){
>          expect(L10n.capitalize("abc")).toEqual("abc".charAt(0).toUpperCase() + "abc".slice(1););
>        });

Пример правильного теста:
>        it('capitalizes',function(){
>          expect(L10n.capitalize("abc")).toEqual("Abc");
>        });

## Виды тестов

На данный момент в системе принято и используется 3 основных вида тестов.

### Простые спеки

Простые тесты, покрывающие тестами модули системы, пишутся для модулей, результат работы которых легко сравнить с некоторым эталонным значением. Хороший пример - модуль преобразования дат:

>        it('is correctly shortens date',function(){
>          expect(GC.dates_formatter.short_digital(1338422400000)).toEqual("31.05");
>        });

В простых спеках как правило используются проверки вида toEqual, toBeTruthy, toBeFalsy, toBe, not.toBe, toBeDefined, toBeUndefined, toBeLessThan, toBeGreaterThan и другие.

### Асинхронные спеки

Асинхронные спеки предназначены для тех частей функционала, которые выполняются асинхронно. Например, если спек попытается прогнать тесты на модуле, который еще не был проинициализирован в ядре, он завершится с ошибкой. Для работы с такими ситуациями предусмотрены команды waitsFor и runs. Блоки runs, идущие друг за другом, позволяют выполнять код последовательно. Пример асинхронных тестов находится в search_history_spec.js. 

Пример асинхронного спека, который ждет инициализации модуля (is_search_loaded - функция):

>       waitsFor(is_search_loaded, "can't init search module", 5000);
>       runs(function(){
>         expect(GC.search_history.is_fresh({
>           attributes: {
>             depart_ts: 2337671311571 //very very far future
>           }
>         })).toBeTruthy();
>       });

### Спеки, основанные на фикстурах

Некоторые части функционала js-приложений в результате своей работы каким-то образом изменяют DOM. Простые спеки не помогут протестировать такой фунционал, поэтому применяют тесты основанные на фикстурах. Фикстура представляет собой html-файл, в котором содержится необходимая для теста html-разметка, например, форма с несколькими полями. Единственное допущение в случае с такими тестами - они могут содержать последовательность действий (воспроизводящую действия пользователя), на основе которой получается некоторый результат. Далее приведен пример с тестированием правильного заполнения формы:

>        it('is correctly fills form',function(){
>          loadFixtures("simple_form.html");
>          var form = new GC.form_helper($("#simple_form"));
>          form.fill({
>            "name_input": "Simple test passed",
>            "check": true
>          });
>          expect($("#check")).toBeChecked();
>          expect($("#name")).toHaveValue("Simple test passed");
>        });

## Выделение функционала, подлежащего покрытию тестами

В системе поддерживается идея максимального сокрытия данных внутри модулей, поэтому некоторый функционал недоступен извне. В таком случае, разработчику необходимо самостоятельно сообщить ядру, какой функционал данного модуля подлежит покрытию тестами. Для этого внутри самого модуля необходимо вызвать метод test() и передать в него объект, содержащий весь необходимый функционал. Далее приведен пример из модуля L10n:

>        sandbox.test({
>          translation: translation,
>          capitalize: capitalize,
>          numerals: numerals,
>          numerals_finder: NumeralsFinder,
>          local_strings: local_strings
>        });

## Особенности jasmine-тестов внутри текущих проектов

В силу особенностей механизма инициализации модулей, из которых состоит приложение, может получиться ситуация, когда тест на модуль будет запускаться раньше, чем инициализироваться сам модуль. Для этого введено специальное ограничение - название теста в блоке describe должно совпадать с названием тестируемого модуля:

>        describe('searches.tickets.layout', function(){

Тесты располагаются структуре директорий, совпадающей со структурой реального приложения:

>        spec/
>          javascripts/
>            ...
>            fixtures/
>            helpers/
>            nano_ui/
>              searches/
>                filters/
>                tickets/
>              utils/

Название файла с тестами должно совпадать с названием тестируемого модуля и содержать постфикс "_spec":

>        L10n_spec.js

В некоторых тестах нужны данные, которых может не быть на момент запуска теста. Для этого необходимо "подождать" данные. Пример того, как тесты перед запуском ждут появления объекта search_results:

>     search_data = {...}
>     beforeEach(function(){
>       ...
>       NANO.api.search.create(search_data, function(results){
>         search_results = results;
>       });
>       waitsFor(function(){
>         return search_results !== null;
>       });
>       ...
>     });

Внутри блока describe может содержаться любое количество блоков it. Блок it - функция, принимающая на вход два параметра:
1. Описание теста. Должно быть выражено в простом повествовательном предложении, которое описывает корректную работу тестируемого блока. Например:

>     it('sends fail signal if no tickets', ...
>     it('is correctly checks history record is new', ...

2. Функция-callback, содержащая код с необходимыми проверками. Рекомендуется использовать максимально строгие из возможных проверок:

>     expect(action(a, b)).toBe(5)
>     expect($('<div id="some-id"></div>')).toBe('div#some-id')

## Документация
* [Документация по Jasmine](https://github.com/pivotal/jasmine/wiki)
* [Документация по Jasmine-jquery](https://github.com/velesin/jasmine-jquery)